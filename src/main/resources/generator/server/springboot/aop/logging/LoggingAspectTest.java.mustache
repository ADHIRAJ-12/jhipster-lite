package {{packageName}}.technical.infrastructure.secondary.aop.logging;

import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mockStatic;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.test.util.ReflectionTestUtils;

import {{packageName}}.UnitTest;

@UnitTest
@ExtendWith(MockitoExtension.class)
public class LoggingAspectTest {
    
    @Mock
    private Logger logger;

    @Mock
    private ProceedingJoinPoint joinPoint;

    @Mock
    private Signature signature;

    private LoggingAspect loggingAspect;

    private static String signatureTypeName = "signature type name";
    private static String signatureName = "signature name";

    private static String exceptionMessage = "exception message";
    private static String exceptionCause = "exception cause";
    private static String exceptionFormatComplete = "Exception in {}() with cause = '{}' and exception = '{}'";
    private static String exceptionFormat = "Exception in {}() with cause = {}";

    private static String enterMessage = "Enter: {}() with argument[s] = {}";
    private static String exitMessage = "Exit: {}() with result = {}";
    private static String illegalMessage = "Illegal argument: {} in {}()";

    private static String joinArgs = "join args";

    @BeforeEach
    public void setup() {
        loggingAspect = new LoggingAspect();
    }

    private void initMocks() {
        when(joinPoint.getSignature()).thenReturn(signature);
        when(signature.getDeclaringTypeName()).thenReturn(signatureTypeName);
    }

    @Test
    public void shouldGetLogger() {
        initMocks();
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);

            loggingAspect.logger(joinPoint);
            
            verify(joinPoint).getSignature();
            verify(signature).getDeclaringTypeName();
            loggerFactory.verify(() -> LoggerFactory.getLogger(signatureTypeName));
        }

    }

    @Test
    public void shouldLogAfterWithLoggingTrueAndExceptionCause() {
        initMocks();
        when(signature.getName()).thenReturn(signatureName);
        ReflectionTestUtils.setField(loggingAspect, "logging", true);
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            Exception exception = new Exception(exceptionMessage, new Exception(exceptionCause));

            loggingAspect.logAfterThrowing(joinPoint, exception);
            
            verify(logger).error(exceptionFormatComplete, signatureName, exception.getCause(), exceptionMessage, exception);
        }
    }

    @Test
    public void shouldLogAfterWithLoggingTrueAndNoExceptionCause() {
        initMocks();
        when(signature.getName()).thenReturn(signatureName);
        ReflectionTestUtils.setField(loggingAspect, "logging", true);
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            Exception exception = new Exception(exceptionMessage);

            loggingAspect.logAfterThrowing(joinPoint, exception);
            
            verify(logger).error(exceptionFormatComplete, signatureName, "NULL", exceptionMessage, exception);
        }
    }

    @Test
    public void shouldLogAfterWithLoggingFalseAndExceptionCause() {
        initMocks();
        when(signature.getName()).thenReturn(signatureName);
        ReflectionTestUtils.setField(loggingAspect, "logging", false);
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            Exception exception = new Exception(exceptionMessage, new Exception(exceptionCause));

            loggingAspect.logAfterThrowing(joinPoint, exception);
            
            verify(logger).error(exceptionFormat, signatureName, exception.getCause());
        }
    }

    @Test
    public void shouldLogAfterWithLoggingFalseAndNoExceptionCause() {
        initMocks();
        when(signature.getName()).thenReturn(signatureName);
        ReflectionTestUtils.setField(loggingAspect, "logging", false);
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            Exception exception = new Exception(exceptionMessage);

            loggingAspect.logAfterThrowing(joinPoint, exception);
            
            verify(logger).error(exceptionFormat, signatureName, "NULL");
        }
    }

    @Test
    public void shouldLogAroundWithDebug() throws Throwable {
        initMocks();
        when(logger.isDebugEnabled()).thenReturn(true);
        when(signature.getName()).thenReturn(signatureName);
        String proceedResult = "proceed result";
        when(joinPoint.proceed()).thenReturn(proceedResult);
        when(joinPoint.getArgs()).thenReturn(new String[]{joinArgs});
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            
            Object result = loggingAspect.logAround(joinPoint);
            
            verify(logger).debug(enterMessage, signatureName, "[" + joinArgs + "]");
            verify(logger).debug(exitMessage, signatureName, proceedResult);
            assertTrue(result.equals(proceedResult));
        }
    }

    @Test
    public void shouldLogAroundWithoutDebug() throws Throwable {
        initMocks();
        when(logger.isDebugEnabled()).thenReturn(false);
        String proceedResult = "proceed result";
        when(joinPoint.proceed()).thenReturn(proceedResult);
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            
            Object result = loggingAspect.logAround(joinPoint);
            assertTrue(result.equals(proceedResult));

            verify(logger, never()).debug(anyString(), any(Object.class), any(Object.class));
        }
    }

    @Test
    public void shouldLogAroundWitProceedException() throws Throwable {
        initMocks();
        when(logger.isDebugEnabled()).thenReturn(false);
        when(signature.getName()).thenReturn(signatureName);
        when(joinPoint.proceed()).thenThrow(IllegalArgumentException.class);
        when(joinPoint.getArgs()).thenReturn(new String[]{joinArgs});
        
        try (MockedStatic<LoggerFactory> loggerFactory = mockStatic(LoggerFactory.class)) {
            loggerFactory.when(() -> LoggerFactory.getLogger(signatureTypeName)).thenReturn(logger);
            
            assertThrows(IllegalArgumentException.class, () -> loggingAspect.logAround(joinPoint));
            verify(logger, never()).debug(anyString(), any(Object.class), any(Object.class));
            verify(logger).error(illegalMessage, "[" + joinArgs + "]", signatureName);
        }
    }

    @Test
    public void shouldSpringBeanPoincut() {
        loggingAspect.springBeanPointcut();
    }

    @Test
    public void shouldApplicationPoincut() {
        loggingAspect.applicationPackagePointcut();
    }

}
